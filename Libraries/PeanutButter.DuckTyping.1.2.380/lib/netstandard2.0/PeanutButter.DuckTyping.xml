<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PeanutButter.DuckTyping</name>
    </assembly>
    <members>
        <member name="T:PeanutButter.DuckTyping.AutoConversion.ConverterExtensions">
            <summary>
            Provides "generic" object-in, object-out conversion extension
            method `Convert(other)` for IConverter implementations
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.AutoConversion.ConverterExtensions.Convert(PeanutButter.DuckTyping.AutoConversion.IConverter,System.Object)">
            <summary>
            Convert the provided object to the converter's other type,
            as an object.
            </summary>
            <param name="converter"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:PeanutButter.DuckTyping.AutoConversion.IConverter`2">
            <summary>
            Implement this interface for two type to provide
            auto-discovered converters to be used when fuzzy-duck-typing
            </summary>
            <typeparam name="T1">Type to convert from or to</typeparam>
            <typeparam name="T2">Type to convert to or from</typeparam>
        </member>
        <member name="M:PeanutButter.DuckTyping.AutoConversion.IConverter`2.Convert(`1)">
            <summary>
            Convert an object of type T2 to T1
            </summary>
            <param name="input">Value to convert</param>
            <returns>Converted value, as implemented by the converter</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.AutoConversion.IConverter`2.Convert(`0)">
            <summary>
            Convert an object of type T1 to T2
            </summary>
            <param name="input">Value to convert</param>
            <returns>Converted value, as implemented by the converter</returns>
        </member>
        <member name="T:PeanutButter.DuckTyping.AutoConversion.IConverter">
            <summary>
            Base interface for converters of all types
            </summary>
        </member>
        <member name="P:PeanutButter.DuckTyping.AutoConversion.IConverter.T1">
            <summary>
            One of the types converted from / to
            This property provides a quick lookup when seeking converters
            </summary>
        </member>
        <member name="P:PeanutButter.DuckTyping.AutoConversion.IConverter.T2">
            <summary>
            The other type converted from / to
            This property provides a quick lookup when seeking converters
            </summary>
        </member>
        <member name="T:PeanutButter.DuckTyping.Comparers.MethodInfoContainer">
            <summary>
            Class which holds two lookups of method information: one accurate and one approximate
            </summary>
        </member>
        <member name="P:PeanutButter.DuckTyping.Comparers.MethodInfoContainer.MethodInfos">
            <summary>
            Accurate dictionary of method information
            </summary>
        </member>
        <member name="P:PeanutButter.DuckTyping.Comparers.MethodInfoContainer.FuzzyMethodInfos">
            <summary>
            Approximate dictionary of method information
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Comparers.MethodInfoContainer.#ctor(System.Reflection.MethodInfo[])">
            <summary>
            Constructs a new instance of the MethodInfo container
            </summary>
            <param name="methodInfos">MethodInfos to contain</param>
        </member>
        <member name="T:PeanutButter.DuckTyping.Create">
            <summary>
            Static class to create instances of automatically generated
            types implementing the provided interfaces
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Create.InstanceOf``1">
            <summary>
            Creates an instance of a type implementing the interface T
            Will generate a type implementing T on the first call and
            re-use it on subsequent calls
            </summary>
            <typeparam name="T">Interface to implement in provided object</typeparam>
            <returns>Instance of an object implementing the provided interface</returns>
        </member>
        <member name="T:PeanutButter.DuckTyping.Exceptions.BackingFieldForPropertyNotFoundException">
            <summary>
            Exception which is thrown when a type does not contain the expected backing field
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Exceptions.BackingFieldForPropertyNotFoundException.#ctor(System.Type,System.String)">
            <summary>
            Constructs an instance of the exception
            </summary>
            <param name="owningType">Type which owns the property which should have a corresponding backing field</param>
            <param name="propertyName">Name of the property which should be backed by a field with the same name and leading underscore</param>
        </member>
        <member name="T:PeanutButter.DuckTyping.Exceptions.MethodNotFoundException">
            <summary>
            Exception thrown when a forced ducked type does not implement
            a method that it is expected to implement
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Exceptions.MethodNotFoundException.#ctor(System.Type,System.String)">
            <summary>
            Constructs an instance of the exception
            </summary>
            <param name="owningType">Type which was expected to implement the method</param>
            <param name="methodName">Name of the method which was expected, but not found</param>
        </member>
        <member name="T:PeanutButter.DuckTyping.Exceptions.ParameterCountMismatchException">
            <summary>
            Exception thrown when a ducked type has a different number of parameters
            for a ducked method than the ducked interface expects
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Exceptions.ParameterCountMismatchException.#ctor(System.Int32,System.Reflection.MethodInfo)">
            <summary>
            Constructs an instance of the exception
            </summary>
            <param name="providedParameters">Number of expected parameters</param>
            <param name="forMethod">Name of the method with a parameter count mismatch</param>
        </member>
        <member name="T:PeanutButter.DuckTyping.Exceptions.PropertyNotFoundException">
            <summary>
            Exception thrown when an expected property was not found on a ducked type
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Exceptions.PropertyNotFoundException.#ctor(System.Type,System.String)">
            <summary>
            Constructs a new instance of the exception
            </summary>
            <param name="owningType">Name of the type expected to implement the property</param>
            <param name="propertyName">Name of the missing expected property</param>
        </member>
        <member name="T:PeanutButter.DuckTyping.Exceptions.ReadOnlyPropertyException">
            <summary>
            Exception thrown when the ducked property is read-only but the interface
            to duck to expects a read/write property
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Exceptions.ReadOnlyPropertyException.#ctor(System.Type,System.String)">
            <summary>
            Constructs an instance of the exception
            </summary>
            <param name="owningType">Type implementing read-only property</param>
            <param name="propertyName">Name of the property which was expected to be writable</param>
        </member>
        <member name="T:PeanutButter.DuckTyping.Exceptions.UnDuckableException">
            <summary>
            The master exception thrown when a type is not duckable and exceptions
            have been enabled
            </summary>
        </member>
        <member name="P:PeanutButter.DuckTyping.Exceptions.UnDuckableException.Errors">
            <summary>
            Collection of errors encountered whilst attempting the requested ducking operation
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Exceptions.UnDuckableException.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructs an instance of the exception
            </summary>
            <param name="errors">Errors to store about the duck failure</param>
        </member>
        <member name="T:PeanutButter.DuckTyping.Exceptions.UnresolveableParameterOrderMismatchException">
            <summary>
            Exception thrown when fuzzy ducking is enabled but the duck
            library cannot resolve the order of parameters to pass into the
            underlying type, usually because there are repeated types amongst the arguments
            (ie, two integers or similar)
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Exceptions.UnresolveableParameterOrderMismatchException.#ctor(System.Type[],System.Reflection.MethodInfo)">
            <summary>
            Constructs an instance of the exception
            </summary>
            <param name="methodParameterTypes">Collection of the parameter types supported by the underlying method, ordered as the underlying method has them ordered</param>
            <param name="methodInfo">MethodInfo object describing the problematic method</param>
        </member>
        <member name="T:PeanutButter.DuckTyping.Exceptions.WriteOnlyPropertyException">
            <summary>
            Exception thrown when a ducking operation expects a read/write
            property but the object being ducked implements a write-only property
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Exceptions.WriteOnlyPropertyException.#ctor(System.Type,System.String)">
            <summary>
            Constructs a new instance of the exception
            </summary>
            <param name="owningType">Underlying type owning the property</param>
            <param name="propertyName">Name of the write-only property</param>
        </member>
        <member name="T:PeanutButter.DuckTyping.Extensions.CustomAttributeHelperExtensions">
            <summary>
            Contains an extension method to craete a CustomAttributeBuilder
            out of CustomAttributeData, largely based on code at:
            http://stackoverflow.com/questions/2365470/using-reflection-emit-to-copy-a-custom-attribute-to-another-method
            (apparently, this is how AutoFac does it!)
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.CustomAttributeHelperExtensions.ToAttributeBuilder(System.Reflection.CustomAttributeData)">
            <summary>
            Creates a CustomAttributeBuilder from the provided CustomAttributeData
            </summary>
            <param name="data">Data to use to create the CustomAttributeBuilder</param>
            <returns>A CustomAttributeBuilder created from the input data</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the provided CustomAttributeData is null</exception>
        </member>
        <member name="T:PeanutButter.DuckTyping.Extensions.DuckTypingCollectionExtensions">
            <summary>
            Provides ducking extensions for collections
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingCollectionExtensions.DuckAsArrayOf``1(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Attempts to DuckType a collection
            </summary>
            <param name="src">Collection to convert</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingCollectionExtensions.DuckAsArrayOf``1(System.Collections.Generic.IEnumerable{System.Object},System.Boolean)">
            <summary>
            Attempts to DuckType a collection
            </summary>
            <param name="src">Collection to convert</param>
            <param name="throwOnFailure">Throw an exception when failing</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions">
            <summary>
            Provides duck-typing extension methods around dictionary objects
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions.ForceFuzzyDuckAs``1(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Forces approximate ducking around a dictionary. Will "create" underlying
            "properties" as required. Will attempt to convert to and from the underlying
            types as required. Will match properties case-insensitive.
            </summary>
            <param name="src"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions.ForceFuzzyDuckAs``1(System.Object)">
            <summary>
            Forces approximate ducking around a dictionary. Will "create" underlying
            "properties" as required. Will attempt to convert to and from the underlying
            types as required. Will match properties case-insensitive.
            </summary>
            <param name="src"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions.ForceDuckAs``1(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Forces ducking around a dictionary. This will expect matching of property
            names (case-sensitive) and types when they are "implemented". Otherwise they
            will be created as required.
            </summary>
            <param name="src"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions.DuckAs``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.Func{System.String,System.String},System.Func{System.String,System.String})">
            <summary>
            Performs ducking with property name redirection
            </summary>
            <param name="src">Dictionary to duck</param>
            <param name="toNativeTransform">Func to transform from keys corresponding to T's interface properties to keys that are found in src</param>
            <param name="fromNativeTransform">Reverse of toNativeTransform</param>
            <typeparam name="T">Interface to duck this dictionary as</typeparam>
            <returns>New instance of an object implementing T, passing through to the dictionary, or null if unable to duck</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions.DuckAs``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.Func{System.String,System.String},System.Func{System.String,System.String},System.Boolean)">
            <summary>
            Performs ducking with property name redirection
            </summary>
            <param name="src">Dictionary to duck</param>
            <param name="toNativeTransform">Func to transform from keys corresponding to T's interface properties to keys that are found in src</param>
            <param name="fromNativeTransform">Reverse of toNativeTransform</param>
            <param name="throwOnError">Flag to throw exception on error instead of just silent failure</param>
            <typeparam name="T">Interface to duck this dictionary as</typeparam>
            <returns>New instance of an object implementing T, passing through to the dictionary, or null if unable to duck</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions.FuzzyDuckAs``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.Func{System.String,System.String},System.Func{System.String,System.String})">
            <summary>
            Performs fuzzy ducking with property name redirection
            </summary>
            <param name="src">Dictionary to duck</param>
            <param name="toNativeTransform">Func to transform from keys corresponding to T's interface properties to keys that are found in src</param>
            <param name="fromNativeTransform">Reverse of toNativeTransform</param>
            <typeparam name="T">Interface to duck this dictionary as</typeparam>
            <returns>New instance of an object implementing T, passing through to the dictionary, or null if unable to duck</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions.FuzzyDuckAs``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.Func{System.String,System.String},System.Func{System.String,System.String},System.Boolean)">
            <summary>
            Performs fuzzy ducking with property name redirection
            </summary>
            <param name="src">Dictionary to duck</param>
            <param name="toNativeTransform">Func to transform from keys corresponding to T's interface properties to keys that are found in src</param>
            <param name="fromNativeTransform">Reverse of toNativeTransform</param>
            <param name="throwOnError">Flag to throw exception on error instead of just silent failure</param>
            <typeparam name="T">Interface to duck this dictionary as</typeparam>
            <returns>New instance of an object implementing T, passing through to the dictionary, or null if unable to duck</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions.FuzzyDuckAs``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
            <summary>
            Fuzzy-Ducks a Dictionary (or part thereof) using a key prefix
            to allow "namespacing" of config
            </summary>
            <param name="src">IDictionary to operate on</param>
            <param name="keyPrefix">key prefix to take into account</param>
            <typeparam name="T">Interface to duck onto</typeparam>
            <returns>new instance of T, wrapping the Dictionary, or null if unduckable</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions.FuzzyDuckAs``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String,System.Boolean)">
            <summary>
            Fuzzy-Ducks a Dictionary (or part thereof) using a key prefix
            to allow "namespacing" of config
            </summary>
            <param name="src">IDictionary to operate on</param>
            <param name="keyPrefix">key prefix to take into account</param>
            <param name="throwOnError">flag: when unduckable, throw instead of just returning null</param>
            <typeparam name="T">Interface to duck onto</typeparam>
            <returns>new instance of T, wrapping the Dictionary, or null if unduckable</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions.DuckAs``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
            <summary>
            Ducks a Dictionary (or part thereof) using a key prefix
            to allow "namespacing" of config
            </summary>
            <param name="src">IDictionary to operate on</param>
            <param name="keyPrefix">key prefix to take into account</param>
            <typeparam name="T">Interface to duck onto</typeparam>
            <returns>new instance of T, wrapping the Dictionary, or null if unduckable</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions.DuckAs``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String,System.Boolean)">
            <summary>
            Ducks a Dictionary (or part thereof) using a key prefix
            to allow "namespacing" of config
            </summary>
            <param name="src">IDictionary to operate on</param>
            <param name="keyPrefix">key prefix to take into account</param>
            <param name="throwOnError">flag: when unduckable, throw instead of just returning null</param>
            <typeparam name="T">Interface to duck onto</typeparam>
            <returns>new instance of T, wrapping the Dictionary, or null if unduckable</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions.FuzzyDuckAs``1(System.Collections.Specialized.NameValueCollection,System.String)">
            <summary>
            Fuzzy-Ducks a NameValueCollection (or part thereof) using a key prefix
            to allow "namespacing" of config
            </summary>
            <param name="src">NameValueCollection to operate on</param>
            <param name="keyPrefix">key prefix to take into account</param>
            <typeparam name="T">Interface to duck onto</typeparam>
            <returns>new instance of T, wrapping the NameValueCollection, or null if unduckable</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions.FuzzyDuckAs``1(System.Collections.Specialized.NameValueCollection,System.String,System.Boolean)">
            <summary>
            Fuzzy-Ducks a NameValueCollection (or part thereof) using a key prefix
            to allow "namespacing" of config
            </summary>
            <param name="src">NameValueCollection to operate on</param>
            <param name="keyPrefix">key prefix to take into account</param>
            <param name="throwOnError">flag: when unduckable, throw instead of just returning null</param>
            <typeparam name="T">Interface to duck onto</typeparam>
            <returns>new instance of T, wrapping the NameValueCollection, or null if unduckable</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions.DuckAs``1(System.Collections.Specialized.NameValueCollection,System.String)">
            <summary>
            Ducks a NameValueCollection (or part thereof) using a key prefix
            to allow "namespacing" of config
            </summary>
            <param name="src">NameValueCollection to operate on</param>
            <param name="keyPrefix">key prefix to take into account</param>
            <typeparam name="T">Interface to duck onto</typeparam>
            <returns>new instance of T, wrapping the NameValueCollection, or null if unduckable</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingDictionaryExtensions.DuckAs``1(System.Collections.Specialized.NameValueCollection,System.String,System.Boolean)">
            <summary>
            Ducks a NameValueCollection (or part thereof) using a key prefix
            to allow "namespacing" of config
            </summary>
            <param name="src">NameValueCollection to operate on</param>
            <param name="keyPrefix">key prefix to take into account</param>
            <param name="throwOnError">flag: when unduckable, throw instead of just returning null</param>
            <typeparam name="T">Interface to duck onto</typeparam>
            <returns>new instance of T, wrapping the NameValueCollection, or null if unduckable</returns>
        </member>
        <member name="T:PeanutButter.DuckTyping.Extensions.DuckTypingExtensionSharedMethods">
            <summary>
            Provides a set of extension methods to enable duck-typing
            </summary>
        </member>
        <member name="T:PeanutButter.DuckTyping.Extensions.DuckTypingNameValueCollectionExtensions">
            <summary>
            Provides duck-typing around NameValueCollections
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingNameValueCollectionExtensions.DuckAs``1(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Ducks a NameValueCollection onto an interface
            </summary>
            <param name="src">NameValueCollection to operate on</param>
            <typeparam name="T">Interface you wish to work through</typeparam>
            <returns>New instance of an object implementing the required interface, if possible; otherwise null</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingNameValueCollectionExtensions.DuckAs``1(System.Collections.Specialized.NameValueCollection,System.Boolean)">
            <summary>
            Ducks a NameValueCollection onto an interface
            </summary>
            <param name="src">NameValueCollection to operate on</param>
            <param name="throwOnError">Flag: throw an exception instead of just returning null</param>
            <typeparam name="T">Interface you wish to work through</typeparam>
            <returns>New instance of an object implementing the required interface</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingNameValueCollectionExtensions.FuzzyDuckAs``1(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Fuzzy-Ducks a NameValueCollection onto an interface, not caring about case or whitespace in property names
            </summary>
            <param name="src">NameValueCollection to operate on</param>
            <typeparam name="T">Interface you wish to work through</typeparam>
            <returns>New instance of an object implementing the required interface, if possible; otherwise null</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingNameValueCollectionExtensions.FuzzyDuckAs``1(System.Collections.Specialized.NameValueCollection,System.Boolean)">
            <summary>
            Fuzzy-Ducks a NameValueCollection onto an interface, not caring about case or whitespace in property names
            </summary>
            <param name="src">NameValueCollection to operate on</param>
            <param name="throwOnError">Flag: throw an exception if cannot duck instead of just returning null</param>
            <typeparam name="T">Interface you wish to work through</typeparam>
            <returns>New instance of an object implementing the required interface, if possible</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingNameValueCollectionExtensions.ForceDuckAs``1(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Forces ducking onto the NameValueCollection. Missing properties return default values when queried and can be set with new values.
            </summary>
            <param name="src">NameValueCollection to operate on</param>
            <typeparam name="T">Interface to duck to</typeparam>
            <returns>New instance of an object implementing the required interface, if possible</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingNameValueCollectionExtensions.ForceFuzzyDuckAs``1(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Forces fuzzy ducking onto the NameValueCollection. Missing properties return default values when queried and can be set with new values.
            </summary>
            <param name="src">NameValueCollection to operate on</param>
            <typeparam name="T">Interface to duck to</typeparam>
            <returns>New instance of an object implementing the required interface, if possible</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingNameValueCollectionExtensions.DuckAs``1(System.Collections.Specialized.NameValueCollection,System.Func{System.String,System.String},System.Func{System.String,System.String})">
            <summary>
            Performs ducking with property name redirection
            </summary>
            <param name="src">Dictionary to duck</param>
            <param name="toNativeTransform">Func to transform from keys corresponding to T's interface properties to keys that are found in src</param>
            <param name="fromNativeTransform">Reverse of toNativeTransform</param>
            <typeparam name="T">Interface to duck this dictionary as</typeparam>
            <returns>New instance of an object implementing T, passing through to the dictionary, or null if unable to duck</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingNameValueCollectionExtensions.DuckAs``1(System.Collections.Specialized.NameValueCollection,System.Func{System.String,System.String},System.Func{System.String,System.String},System.Boolean)">
            <summary>
            Performs ducking with property name redirection
            </summary>
            <param name="src">Dictionary to duck</param>
            <param name="toNativeTransform">Func to transform from keys corresponding to T's interface properties to keys that are found in src</param>
            <param name="fromNativeTransform">Reverse of toNativeTransform</param>
            <param name="throwOnError">Flag to throw exception on error instead of just silent failure</param>
            <typeparam name="T">Interface to duck this dictionary as</typeparam>
            <returns>New instance of an object implementing T, passing through to the dictionary, or null if unable to duck</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingNameValueCollectionExtensions.FuzzyDuckAs``1(System.Collections.Specialized.NameValueCollection,System.Func{System.String,System.String},System.Func{System.String,System.String})">
            <summary>
            Performs fuzzy ducking with property name redirection
            </summary>
            <param name="src">Dictionary to duck</param>
            <param name="toNativeTransform">Func to transform from keys corresponding to T's interface properties to keys that are found in src</param>
            <param name="fromNativeTransform">Reverse of toNativeTransform</param>
            <typeparam name="T">Interface to duck this dictionary as</typeparam>
            <returns>New instance of an object implementing T, passing through to the dictionary, or null if unable to duck</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingNameValueCollectionExtensions.FuzzyDuckAs``1(System.Collections.Specialized.NameValueCollection,System.Func{System.String,System.String},System.Func{System.String,System.String},System.Boolean)">
            <summary>
            Performs fuzzy ducking with property name redirection
            </summary>
            <param name="src">Dictionary to duck</param>
            <param name="toNativeTransform">Func to transform from keys corresponding to T's interface properties to keys that are found in src</param>
            <param name="fromNativeTransform">Reverse of toNativeTransform</param>
            <param name="throwOnError">Flag to throw exception on error instead of just silent failure</param>
            <typeparam name="T">Interface to duck this dictionary as</typeparam>
            <returns>New instance of an object implementing T, passing through to the dictionary, or null if unable to duck</returns>
        </member>
        <member name="T:PeanutButter.DuckTyping.Extensions.DuckTypingObjectExtensions">
            <summary>
            Provides a set of extension methods to enable duck-typing
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingObjectExtensions.CanDuckAs``1(System.Object)">
            <summary>
            Tests whether or not a given object can be accurately duck-typed to the
            requested interface T. Accurate duck-typing requires exact matching of
            property names and types as well as method names and signatures.
            </summary>
            <param name="src">Object to inspect</param>
            <typeparam name="T">Desired interface to duck to</typeparam>
            <returns>True when the object can be accurately duck-typed; false otherwise. A false result here may not necessarily mean a false result from CanFuzzyDuckAs</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingObjectExtensions.CanFuzzyDuckAs``1(System.Object)">
            <summary>
            Tests whether or not a given object can be approximately duck-typed to the
            requested interface T. Fuzzy ducking will attempt to bridge when there are case
            mismatches in property and method names as well as attempting auto-conversion
            between underlying and exposed types (eg: a Guid property could be backed by
            an underlying string property) and will attempt parameter re-ordering when
            ducking methods, if required and possible.
            </summary>
            <param name="src">Object to inspect</param>
            <typeparam name="T">Desired interface to duck to</typeparam>
            <returns>True when the object can be approximately duck-typed; false otherwise</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingObjectExtensions.DuckAs``1(System.Object)">
            <summary>
            Attempts to accurately duck-type an object to an interface.
            </summary>
            <param name="src">Object to duck-type</param>
            <typeparam name="T">Interface required</typeparam>
            <returns>
            If accurate ducking is possible, this method returns a new object which wraps
            around the input object, exposing the properties and methods of the requested
            interface whilst calling through to the underlying object. If ducking cannot be
            achieved, this method silently returns null.
            </returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingObjectExtensions.DuckAs``1(System.Object,System.Boolean)">
            <summary>
            Attempts to accurately duck-type an object to an interface.
            </summary>
            <param name="src">Object to duck-type</param>
            <param name="throwOnError">Flag to allow throwing and exception when ducking cannot be achieved.
            The thrown exception contains information about what caused ducking to fail.</param>
            <typeparam name="T">Interface required</typeparam>
            <returns>
            If accurate ducking is possible, this method returns a new object which wraps
            around the input object, exposing the properties and methods of the requested
            interface whilst calling through to the underlying object. If ducking cannot be
            achieved, this method silently returns null when throwOnError is false or throws
            an UnDuckableException if throwOnError is true.
            </returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingObjectExtensions.FuzzyDuckAs(System.Object,System.Type)">
            <summary>
            Attempts to approximately duck-type an object to a a provided interface type
            </summary>
            <param name="src">Object to duck-type</param>
            <param name="toType">Type of interface required</param>
            <returns>
            If approximate ducking is possible, this method returns a new object which wraps
            around the input object, exposing the properties and methods of the requested
            interface whilst calling through to the underlying object. If ducking cannot be
            achieved, this method silently returns null.
            </returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingObjectExtensions.FuzzyDuckAs(System.Object,System.Type,System.Boolean)">
            <summary>
            Attempts to approximately duck-type an object to a a provided interface type
            </summary>
            <param name="src">Object to duck-type</param>
            <param name="toType">Type of interface required</param>
            <param name="throwOnError">Flag to determine whether failure to duck should throw an exception</param>
            <returns>
            If approximate ducking is possible, this method returns a new object which wraps
            around the input object, exposing the properties and methods of the requested
            interface whilst calling through to the underlying object. If ducking cannot be
            achieved, this method silently returns null when throwOnError is false or throws
            an UnDuckableException when throwOnError is true.
            </returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingObjectExtensions.DuckAs(System.Object,System.Type)">
            <summary>
            Attempts to accurately duck-type an object to a a provided interface type
            </summary>
            <param name="src">Object to duck-type</param>
            <param name="toType">Type of interface required</param>
            <returns>
            If accurate ducking is possible, this method returns a new object which wraps
            around the input object, exposing the properties and methods of the requested
            interface whilst calling through to the underlying object. If ducking cannot be
            achieved, this method silently returns null.
            </returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingObjectExtensions.DuckAs(System.Object,System.Type,System.Boolean)">
            <summary>
            Attempts to accurately duck-type an object to a a provided interface type
            </summary>
            <param name="src">Object to duck-type</param>
            <param name="toType">Type of interface required</param>
            <param name="throwOnError">Flag to determine whether failure to duck should throw an exception</param>
            <returns>
            If accurate ducking is possible, this method returns a new object which wraps
            around the input object, exposing the properties and methods of the requested
            interface whilst calling through to the underlying object. If ducking cannot be
            achieved, this method silently returns null when throwOnError is false or throws
            an UnDuckableException when throwOnError is true.
            </returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingObjectExtensions.FuzzyDuckAs``1(System.Object)">
            <summary>
            Attempts to approximately duck-type an object to a a provided interface type
            </summary>
            <param name="src">Object to duck-type</param>
            <paramtype name="T">Type of interface required</paramtype>
            <returns>
            If approximate ducking is possible, this method returns a new object which wraps
            around the input object, exposing the properties and methods of the requested
            interface whilst calling through to the underlying object. If ducking cannot be
            achieved, this method silently returns null.
            </returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.DuckTypingObjectExtensions.FuzzyDuckAs``1(System.Object,System.Boolean)">
            <summary>
            Attempts to approximately duck-type an object to a a provided interface type
            </summary>
            <param name="src">Object to duck-type</param>
            <param name="throwOnError">Flag to determine whether failure to duck should throw an exception</param>
            <paramtype name="T">Type of interface required</paramtype>
            <returns>
            If approximate ducking is possible, this method returns a new object which wraps
            around the input object, exposing the properties and methods of the requested
            interface whilst calling through to the underlying object. If ducking cannot be
            achieved, this method silently returns null when throwOnError is false or throws
            an UnDuckableException when throwOnError is true.
            </returns>
        </member>
        <member name="T:PeanutButter.DuckTyping.Extensions.MergingExtensions">
            <summary>
            Provides extension method for merging multiple objects behind a
            required interface
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.MergingExtensions.CanMergeAs``1(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Tests if a collection of objects can back
            the given interface T
            </summary>
            <param name="sources"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.MergingExtensions.CanFuzzyMergeAs``1(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Tests if a collection of objects can back
            the given interface T (fuzzy)
            </summary>
            <param name="sources"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.MergingExtensions.MergeAs``1(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Attempts to merge a collection of objects onto one interface, first wins
            </summary>
            <param name="sources"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.MergingExtensions.MergeAs``1(System.Collections.Generic.IEnumerable{System.Object},System.Boolean)">
            <summary>
            Attempts to merge a collection of objects onto one interface, first wins
            </summary>
            <param name="sources"></param>
            <param name="throwOnError"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.MergingExtensions.FuzzyMergeAs``1(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Attempts to fuzzy-merge a collection of objects onto one interface, first wins
            </summary>
            <param name="sources"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Extensions.MergingExtensions.FuzzyMergeAs``1(System.Collections.Generic.IEnumerable{System.Object},System.Boolean)">
            <summary>
            Attempts to fuzzy-merge a collection of objects onto one interface, first wins
            </summary>
            <param name="sources"></param>
            <param name="throwOnError"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:PeanutButter.DuckTyping.Shimming.DictionaryShimSham">
            <summary>
            Provides the required shimming to duck a dictionary object to an interface
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryShimSham.#ctor(System.Collections.Generic.IDictionary{System.String,System.Object},System.Type)">
            <summary>
            Constructs an instance of the DictionaryShimSham
            </summary>
            <param name="toWrap">Dictionary to wrap</param>
            <param name="interfaceToMimic">Interface that must be mimicked</param>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryShimSham.#ctor(System.Collections.Generic.IDictionary{System.String,System.Object}[],System.Type)">
            <summary>
            Constructs an instance of the DictionaryShimSham
            </summary>
            <param name="toWrap">Dictionaries to wrap (wip: only the first is considered)</param>
            <param name="interfaceToMimic">Interface that must be mimicked</param>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryShimSham.GetPropertyValue(System.String)">
            <summary>
            Gets the value of a property by name
            </summary>
            <param name="propertyName">Name of the property to get the value of</param>
            <returns>The value of the property, where possible.
            May return the default value for the property type when it is not found
            and may attempt automatic conversion when the type to represent does not
            match the underlying type</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryShimSham.SetPropertyValue(System.String,System.Object)">
            <summary>
            Attempts to set the value of the named property
            </summary>
            <param name="propertyName">Name of the property to set</param>
            <param name="newValue">Value to set. The value may be converted to match the underlying type when required.</param>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryShimSham.CallThroughVoid(System.String,System.Object[])">
            <summary>
            Required to implement the IShimSham interface, but not implemented for
            dictionaries as the concept doesn't make sense
            </summary>
            <param name="methodName">Name of the method to not call through to</param>
            <param name="parameters">Parameters to ignore</param>
            <exception cref="T:System.NotImplementedException">Exception which is always thrown</exception>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryShimSham.CallThrough(System.String,System.Object[])">
            <summary>
            Required to implement the IShimSham interface, but not implemented for
            dictionaries as the concept doesn't make sense
            </summary>
            <param name="methodName">Name of the method to not call through to</param>
            <param name="parameters">Parameters to ignore</param>
            <exception cref="T:System.NotImplementedException">Exception which is always thrown</exception>
        </member>
        <member name="T:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection">
            <summary>
            Wraps a NameValueCollection in an IDictionary interface
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.#ctor(System.Collections.Specialized.NameValueCollection,System.Boolean)">
            <summary>
            Construct this dictionary with a NameValueCollection to wrap,
            specifying whether or not key lookups are to be case-sensitive
            </summary>
            <param name="data"></param>
            <param name="caseInsensitive">Flag: is this collection to treat keys case-insensitive?</param>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.#ctor(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Construct this dictionary with a NameValueCollection to wrap
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.#ctor(System.Collections.Specialized.NameValueCollection,System.StringComparer)">
            <summary>
            Construct this dictionary with a NameValueCollection to wrap,
            specifying the StringComparer to use when comparing requested
            keys with available keys
            </summary>
            <param name="data"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.Clear">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="P:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.Count">
            <inheritdoc />
        </member>
        <member name="P:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.ContainsKey(System.String)">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.Add(System.String,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.Remove(System.String)">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.TryGetValue(System.String,System.Object@)">
            <inheritdoc />
        </member>
        <member name="P:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.Item(System.String)">
            <inheritdoc />
        </member>
        <member name="P:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.Keys">
            <inheritdoc />
        </member>
        <member name="P:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection.Values">
            <inheritdoc />
        </member>
        <member name="T:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollectionEnumerator">
            <summary>
            Wraps a NameValueCollection in a Dictionary interface
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollectionEnumerator.#ctor(PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollection)">
            <summary>
            Provides an IEnumerator for a DictionaryWrappingNameValueCollection
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollectionEnumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollectionEnumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.DictionaryWrappingNameValueCollectionEnumerator.Reset">
            <inheritdoc />
        </member>
        <member name="T:PeanutButter.DuckTyping.Shimming.IPropertyInfoFetcher">
            <summary>
            Interface to implement for a utility to fetch properties on a type or object
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.IPropertyInfoFetcher.GetProperties(System.Type,System.Reflection.BindingFlags)">
            <summary>
            Fetches properties from a type which conform to the provided binding flags
            </summary>
            <param name="srcType">Type to inspect</param>
            <param name="bindingFlags">Binding Flags to match</param>
            <returns>Array of all properties found on the type which match the given binding flags</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.IPropertyInfoFetcher.GetPropertiesFor(System.Object,System.Reflection.BindingFlags)">
            <summary>
            Fetches properties from an object which conform to the provided binding flags
            </summary>
            <param name="obj">Object to inspect</param>
            <param name="bindingFlags">Binding Flags to match</param>
            <returns>Array of all properties found on the object which match the given binding flags</returns>
        </member>
        <member name="T:PeanutButter.DuckTyping.Shimming.IsADuckAttribute">
            <summary>
            Attribute added to all types created by the TypeMaker, usually consumed
            during efforts to duck-type
            </summary>
        </member>
        <member name="T:PeanutButter.DuckTyping.Shimming.IShimSham">
            <summary>
            Interface to implement for shimming ducked-types. Used for the backing
            field within the ducked type. Could potentially be used as a starting point
            for new ways to duck.
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.IShimSham.GetPropertyValue(System.String)">
            <summary>
            Gets a property value from the underlying object
            </summary>
            <param name="propertyName">Name of the property to get the value for</param>
            <returns>Value of the underlying property</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.IShimSham.SetPropertyValue(System.String,System.Object)">
            <summary>
            Sets a property value on the underlying object
            </summary>
            <param name="propertyName">Name of the property to set</param>
            <param name="newValue">Value to set</param>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.IShimSham.CallThroughVoid(System.String,System.Object[])">
            <summary>
            Calls through to an underlying void-returning method
            </summary>
            <param name="methodName">Name of the method to call through to</param>
            <param name="parameters">Parameters to pass through to the method</param>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.IShimSham.CallThrough(System.String,System.Object[])">
            <summary>
            Calls through to an underlying method and returns the result
            </summary>
            <param name="methodName">Name of the method to call through to</param>
            <param name="parameters">Parameters to pass through to the method</param>
            <returns>Value returned from the underlying method</returns>
        </member>
        <member name="T:PeanutButter.DuckTyping.Shimming.ITypeMaker">
            <summary>
            Interface implemented by the TypeMaker
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ITypeMaker.MakeTypeImplementing``1">
            <summary>
            Attempts to create a type implementing interface T
            The created type will have constructors supporting parameterless construction
            as well as duck-typing construction
            </summary>
            <typeparam name="T">Interface to implement</typeparam>
            <returns>A new type implementing interface T</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ITypeMaker.MakeTypeImplementing(System.Type)">
            <summary>
            Attempts to create a type implementing interface T
            The created type will have constructors supporting parameterless construction
            as well as duck-typing construction
            </summary>
            <param name="interfaceType">Interface to implement</param>
            <returns>A new type implementing interfaceType</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ITypeMaker.MakeFuzzyTypeImplementing``1">
            <summary>
            Attempts to create a type implementing interface T
            The created type will have constructors supporting parameterless construction
            as well as duck-typing construction for approximate duck-typing (which also
            supports accurate duck-typing)
            </summary>
            <typeparam name="T">Interface to implement</typeparam>
            <returns>A new type implementing interface T</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ITypeMaker.MakeFuzzyTypeImplementing(System.Type)">
            <summary>
            Attempts to create a type implementing interface T
            The created type will have constructors supporting parameterless construction
            as well as duck-typing construction for approximate duck-typing (which also
            supports accurate duck-typing)
            </summary>
            <param name="interfaceType">Interface to implement</param>
            <returns>A new type implementing interfaceType</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ITypeMaker.MakeFuzzyDefaultingTypeImplementing``1">
            <summary>
            Attempts to create a type implementing interface T
            The created type will have constructors supporting parameterless construction
            as well as duck-typing construction for approximate duck-typing (which also
            supports accurate duck-typing) where missing properties on the ducked source
            are readable as the default value for that property's type
            </summary>
            <returns>A new type implementing interface T</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ITypeMaker.MakeFuzzyDefaultingTypeImplementing(System.Type)">
            <summary>
            Attempts to create a type implementing interface T
            The created type will have constructors supporting parameterless construction
            as well as duck-typing construction for approximate duck-typing (which also
            supports accurate duck-typing) where missing properties on the ducked source
            are readable as the default value for that property's type
            </summary>
            <param name="interfaceType">Interface to implement</param>
            <returns>A new type implementing interfaceType</returns>
        </member>
        <member name="T:PeanutButter.DuckTyping.Shimming.PropertyInfoContainer">
            <summary>
            Provides a container for two property info lookups: one accurate and one approximate
            </summary>
        </member>
        <member name="P:PeanutButter.DuckTyping.Shimming.PropertyInfoContainer.PropertyInfos">
            <summary>
            Accurate property info lookup
            </summary>
        </member>
        <member name="P:PeanutButter.DuckTyping.Shimming.PropertyInfoContainer.FuzzyPropertyInfos">
            <summary>
            Approximate property info lookup
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.PropertyInfoContainer.#ctor(System.Reflection.PropertyInfo[])">
            <summary>
            Constructs a new instance of the lookup container
            </summary>
            <param name="propertyInfos">PropertyInfos to contain</param>
        </member>
        <member name="T:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1">
            <summary>
            Provides a wrapping read-write layer around another dictionary effectively
                allowing transparent rename of the keys
            </summary>
            <typeparam name="TValue">Type of values stored</typeparam>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.#ctor(System.Collections.Generic.IDictionary{System.String,`0},System.Func{System.String,System.String},System.Func{System.String,System.String})">
            <summary>
            Constructs a new RedirectingDictionary
            </summary>
            <param name="data">Data to wrap</param>
            <param name="toNativeTransform">Function to transform keys from those used against this object to native ones in the data parameter</param>
            <param name="fromNativeTransform">Function to transform keys from those in the data object (native) to those presented by this object</param>
            <exception cref="T:System.ArgumentNullException">Thrown if null data or key transform are supplied </exception>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.Add(System.Collections.Generic.KeyValuePair{System.String,`0})">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.Contains(System.Collections.Generic.KeyValuePair{System.String,`0})">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.CopyTo(System.Collections.Generic.KeyValuePair{System.String,`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.Remove(System.Collections.Generic.KeyValuePair{System.String,`0})">
            <inheritdoc />
        </member>
        <member name="P:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.Count">
            <inheritdoc />
        </member>
        <member name="P:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.ContainsKey(System.String)">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.Add(System.String,`0)">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.Remove(System.String)">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.TryGetValue(System.String,`0@)">
            <inheritdoc />
        </member>
        <member name="P:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.Item(System.String)">
            <inheritdoc />
        </member>
        <member name="P:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.Keys">
            <inheritdoc />
        </member>
        <member name="P:PeanutButter.DuckTyping.Shimming.RedirectingDictionary`1.Values">
            <inheritdoc />
        </member>
        <member name="T:PeanutButter.DuckTyping.Shimming.ShimSham">
            <summary>
            Shim to wrap objects for ducking
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ShimSham.#ctor(System.Object[],System.Type,System.Boolean,System.Boolean)">
            <summary>
            Constructs a new instance of the ShimSham with a DefaultPropertyInfoFetcher
            </summary>
            <param name="toWrap">Objects to wrap (wip: only the first object is considered)</param>
            <param name="interfaceToMimic">Interface type to mimick</param>
            <param name="isFuzzy">Flag allowing or preventing approximation</param>
            <param name="allowReadonlyDefaultMembers">allows properties with no backing to be read as the default value for that type</param>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ShimSham.#ctor(System.Object,System.Type,System.Boolean,System.Boolean)">
            <summary>
            Constructs a new instance of the ShimSham with the provided property info fetcher
            </summary>
            <param name="toWrap">Object to wrap</param>
            <param name="interfaceToMimic">Interface type to mimick</param>
            <param name="isFuzzy">Flag allowing or preventing approximation</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the mimick interface or property info fetch are null</exception>
            <param name="allowReadonlyDefaultMembers">allows properties with no backing to be read as the default value for that type</param>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ShimSham.#ctor(System.Object[],System.Type,System.Boolean,System.Boolean,PeanutButter.DuckTyping.Shimming.IPropertyInfoFetcher)">
            <summary>
            Constructs a new instance of the ShimSham with the provided property info fetcher
            </summary>
            <param name="toWrap">Objects to wrap (wip: only the first object is considered)</param>
            <param name="interfaceToMimic">Interface type to mimick</param>
            <param name="isFuzzy">Flag allowing or preventing approximation</param>
            <param name="allowReadonlyDefaultsForMissingMembers">Whether to allow returning default(T) for properties which are missing on the wrapped source(s)</param>
            <param name="propertyInfoFetcher">Utility to fetch property information from the provided object and interface type</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the mimick interface or property info fetch are null</exception>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ShimSham.GetPropertyValue(System.String)">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ShimSham.SetPropertyValue(System.String,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ShimSham.CallThroughVoid(System.String,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ShimSham.CallThrough(System.String,System.Object[])">
            <inheritdoc />
        </member>
        <member name="T:PeanutButter.DuckTyping.Shimming.ShimShamBase">
            <summary>
            Base class for common shim functionality
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ShimShamBase.GetDefaultValueFor(System.Type)">
            <summary>
            Gets the default value for a type
            </summary>
            <param name="correctType">Type to find the default value for</param>
            <returns>The value that would be returned by default(T) for that type</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ShimShamBase.ConvertWith(PeanutButter.DuckTyping.AutoConversion.IConverter,System.Object,System.Type)">
            <summary>
            Converts a property value from original type to another type using the provided converter
            </summary>
            <param name="converter">Converts the value</param>
            <param name="propValue">Value to convert</param>
            <param name="toType">Required output type</param>
            <returns>Value converted to required output type, where possible</returns>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.ShimShamBase.MakeTypeToImplement(System.Type,System.Boolean)">
            <summary>
            Creates a new type to implement the requested interface type
            Used internally when fleshing out non-primitive properties
            </summary>
            <param name="type">Type to implement</param>
            <param name="isFuzzy">Flag to allow (or not) approximate / fuzzy ducking</param>
            <returns>Type implementing requested interface</returns>
        </member>
        <member name="T:PeanutButter.DuckTyping.Shimming.TypeMaker">
            <summary>
            Utility class to create types on the fly which implement provided interfaces,
            when possible.
            </summary>
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.TypeMaker.MakeTypeImplementing``1">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.TypeMaker.MakeTypeImplementing(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.TypeMaker.MakeFuzzyTypeImplementing``1">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.TypeMaker.MakeFuzzyTypeImplementing(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.TypeMaker.MakeFuzzyDefaultingTypeImplementing``1">
            <inheritdoc />
        </member>
        <member name="M:PeanutButter.DuckTyping.Shimming.TypeMaker.MakeFuzzyDefaultingTypeImplementing(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1">
            <summary>
            Provides a read/write-through shim for another dictionary with
            the desired case sensitivity access
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.Keys">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.Values">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.Comparer">
            <summary>
            Provides read-only access to the StringComparer used to match keys
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.#ctor(System.Collections.Generic.IDictionary{System.String,`0})">
            <summary>
            Constructs a CaseWarpingDictionaryWrapper around the provided
            actual dictionary with no case-warping
            </summary>
            <param name="actual"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.#ctor(System.Collections.Generic.IDictionary{System.String,`0},System.Boolean)">
            <summary>
            Constructs a CaseWarpingDictionaryWrapper around the provided
            actual dictionary with specified case sensitivity
            </summary>
            <param name="actual"></param>
            <param name="caseInsensitive"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.#ctor(System.Collections.Generic.IDictionary{System.String,`0},System.StringComparer)">
            <summary>
            Constructs a CaseWarpingDictionaryWrapper around the provided
            actual dictionary with the provided StringComparer used to look
            up keys
            </summary>
            <param name="actual"></param>
            <param name="keyComparer"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.Add(System.Collections.Generic.KeyValuePair{System.String,`0})">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.Add(System.String,`0)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.Contains(System.Collections.Generic.KeyValuePair{System.String,`0})">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.CopyTo(System.Collections.Generic.KeyValuePair{System.String,`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.Remove(System.Collections.Generic.KeyValuePair{System.String,`0})">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.ContainsKey(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.Remove(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.TryGetValue(System.String,`0@)">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.CaseWarpingDictionaryWrapper`1.Item(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2">
            <summary>
            Provides a Dictionary class which returns default values for unknown keys
            (like Python's defaultdict)
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.Comparer">
            <summary>
            Always report as case- and culture- insensitive
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.#ctor">
            <summary>
            Constructs a DefaultDictionary where missing key lookups
            return the default value for TValue
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.#ctor(System.Func{`1})">
            <summary>
            Constructs a DefaultDictionary where missing key lookups
            return the value provided by the default resolver
            </summary>
            <param name="defaultResolver"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.#ctor(System.Func{`0,`1})">
            <summary>
            Constructs a DefaultDictionary where missing key lookups
            return the value provided by the default resolver
            </summary>
            <param name="smartResolver"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.GetEnumerator">
            <summary>
            Gets an enumerator for known items in the dictionary
            </summary>
            <returns>Enumerator of TKey/TValue</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds an item to the dictionary
            </summary>
            <param name="item">KeyValuePair to add</param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.Clear">
            <summary>
            Removes all known items from the dictionary
            -> NB: you'll still get default values!
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Searches for an item in the dictionary
            </summary>
            <param name="item">Item to search for</param>
            <returns>True if found, False otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies known items to the target array
            </summary>
            <param name="array">Array to copy to</param>
            <param name="arrayIndex">position to start copying at</param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes an item from the dictionary
            </summary>
            <param name="item">Item to remove</param>
            <returns>True if found and removed, False otherwise</returns>
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.Count">
            <summary>
            Gives the count of known items in the dictionary
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.IsReadOnly">
            <summary>
            Always returns false - DefaultDictionaries are writable!
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.ContainsKey(`0)">
            <summary>
            Always returns true - if the key is "unknown" a default can still be provided
            </summary>
            <param name="key">Key to search for</param>
            <returns>True</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.Add(`0,`1)">
            <summary>
            Adds an item by key, value to the dictionary
            </summary>
            <param name="key">Key to add</param>
            <param name="value">Value to add</param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.Remove(`0)">
            <summary>
            Removes an item by key from the dictionary
            </summary>
            <param name="key">Key to remove</param>
            <returns>True if found and removed, False otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get a known value for the key, falling back on the default value
            </summary>
            <param name="key">Key to look up</param>
            <param name="value">(out) parameter containing looked up (or default) value</param>
            <returns>Always true</returns>
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.Item(`0)">
            <summary>
            Index into the dictionary
            </summary>
            <param name="key">Key to look up</param>
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.Keys">
            <summary>
            Returns a collection of all known keys
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.DefaultDictionary`2.Values">
            <summary>
            Returns a collection of all known values
            </summary>
        </member>
        <member name="T:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject">
            <summary>
            Wraps an object in a dictionary interface
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.Comparer">
            <summary>
            The string comparer used to locate keys
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.#ctor(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.#ctor(System.Object,System.StringComparer)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.Clear">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.Count">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.ContainsKey(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.Add(System.String,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.Remove(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.TryGetValue(System.String,System.Object@)">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.Item(System.String)">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.Keys">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.DictionaryWrappingObject.Values">
            <inheritdoc />
        </member>
        <member name="T:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2">
            <summary>
            Provides a mechanism to merge multiple dictionaries into one
            Source dictionaries
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.Comparer">
            <summary>
            Expose the first (or least-restrictive, for strings) key comparer
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1}[])">
            <summary>
            Construct MergeDictionary over other dictionaries
            </summary>
            <param name="layers"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.GetEnumerator">
            <summary>
            Gets an Enumerator for the KeyValuePairs in this merged
            dictionary, prioritised by the order of provided layers
            </summary>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Will throw - MergeDictionary is read-only
            </summary>
            <param name="item"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.Clear">
            <summary>
            Will throw - MergeDictionary is read-only
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Returns true if any layer contains the provided item
            </summary>
            <param name="item">Item to search for</param>
            <returns>True if found, False if not</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the prioritised items to the provided array from the given arrayIndex
            </summary>
            <param name="array">Target array to copy to</param>
            <param name="arrayIndex">Index to start copying at</param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Will throw an exception - MergeDictionary is read-only
            </summary>
            <param name="item">Item to remove</param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.Count">
            <summary>
            Returns the count of distinct keys
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.IsReadOnly">
            <summary>
            Will return true: MergeDictionaries are read-only
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.ContainsKey(`0)">
            <summary>
            Searches for the given key across all layers
            </summary>
            <param name="key">Key to search for</param>
            <returns>True if found, False otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.Add(`0,`1)">
            <summary>
            Will throw - MergeDictionaries are read-only
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.Remove(`0)">
            <summary>
            Will throw - MergeDictionaries are read-only
            </summary>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get a value by key from the underlying layers
            </summary>
            <param name="key">Key to search for</param>
            <param name="value">Value to search for</param>
            <returns>True if found, False otherwise</returns>
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.Item(`0)">
            <summary>
            Index into the layers to find the highest-priority match for the
            provided key
            </summary>
            <param name="key">Key to look up</param>
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.Keys">
            <summary>
            Returns a collection of the distinct keys in all layers
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.Dictionaries.MergeDictionary`2.Values">
            <summary>
            Returns a collection of ALL values in all layers
            </summary>
        </member>
        <member name="T:Imported.PeanutButter.Utils.ExtensionsForIEnumerables">
            <summary>
            Useful extensions for IEnumerable&lt;T&gt; collections
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            The missing ForEach method
            </summary>
            <param name="collection">Subject collection to operate over</param>
            <param name="toRun">Action to run on each member of the collection</param>
            <typeparam name="T">Item type of the collection</typeparam>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            The missing ForEach method - synchronous variant which also provides the current item index
            </summary>
            <param name="collection">Subject collection to operate over</param>
            <param name="toRunWithIndex">Action to run on each member of the collection</param>
            <typeparam name="T">Item type of the collection</typeparam>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.IsSameAs``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Calculates if two collections hold the same items, irrespective of order
            </summary>
            <param name="collection">Source collection</param>
            <param name="otherCollection">Collection to compare with</param>
            <typeparam name="T">Item type of the collections</typeparam>
            <returns>True if all values in the source collection are found in the target collection</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.JoinWith``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Fluent alternative to string.Join()
            </summary>
            <param name="collection">Source collection to operate on</param>
            <param name="joinWith">String to join items with</param>
            <typeparam name="T">Underlying type of the collection</typeparam>
            <returns>
            string representing items of the collection joined with the joinWith parameter.
            Where a collection of non-strings is provided, the objects' ToString() methods
            are used to get a string representation.
            </returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Convenience method, essentially opposite to Any(), except
            that it also handles null collections
            </summary>
            <param name="collection">Source collection to operate on</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>True if the collection is null or has no items; false otherwise.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.EmptyIfNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Convenience method to mitigate null checking and errors when
            a null collection can be treated as if it were empty, eg:
            someCollection.EmptyIfNull().ForEach(DoSomething);
            </summary>
            <param name="collection">Source collection to operate over</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>An empty collection if the source is null; otherwise the source.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.And``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Convenience method to create a new array with the provided element(s) appended
            </summary>
            <param name="source">Source array to start with</param>
            <param name="toAdd">Item(s) to add to the result array</param>
            <typeparam name="T">Item type of the array</typeparam>
            <returns>A new array which is the source with the new items appended</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.ButNot``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Convenience / fluent method to provide an array without the provided item(s)
            </summary>
            <param name="source">Source collection</param>
            <param name="toRemove">items which should not appear in the result array</param>
            <typeparam name="T">Item type of the array</typeparam>
            <returns>A new array of T with the specified items not present</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.Flatten``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Convenience wrapper around SelectMany; essentially flattens a nested collection
            of collection(s) of some item. Exactly equivalent to:
            collection.SelectMany(o => o);
            </summary>
            <param name="collection">Source collection to operate on</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>A new, flat collection</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.SelectNonNull``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{``1}})">
            <summary>
            Convenience method to get the results of a selection where the results are non-null
            -> this variant works on Nullable types
            </summary>
            <param name="collection">Source collection to operate over</param>
            <param name="grabber">Function to grab the data you're interested in off of each source item</param>
            <typeparam name="TCollection">Item type of the source collection</typeparam>
            <typeparam name="TResult">Item type of the result collection</typeparam>
            <returns>
            A new collection which is the result of a Select with the provided grabber
            where the Select results are non-null
            </returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.SelectNonNull``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Convenience method to get the results of a selection where the results are non-null
            -> this variant works on types which can natively hold the value null
            </summary>
            <param name="collection">Source collection to operate over</param>
            <param name="grabber">Function to grab the data you're interested in off of each source item</param>
            <typeparam name="TCollection">Item type of the source collection</typeparam>
            <typeparam name="TResult">Item type of the result collection</typeparam>
            <returns>
            A new collection which is the result of a Select with the provided grabber
            where the Select results are non-null
            </returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.AsText``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Convenience method to produce a block of text from a collection of items
            -> optionally, delimit with a string of your choice instead of a newline
            -> essentially a wrapper around JoinWith()
            </summary>
            <param name="input">Source input lines</param>
            <param name="delimiter">Optional delimiter (default is Environment.NewLine)</param>
            <typeparam name="T">Item type of collection</typeparam>
            <returns>String representation of the the items</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.HasUnique``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Convenience method to test if a collection has a single item matching the
            provided matcher function
            </summary>
            <param name="input">Source collection</param>
            <param name="matcher">Function to run over each item to test if it passes</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>
            True if only one item in the collection got a true value from the matcher
            function; false if zero or more than one items were matched.
            </returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.TimesDo(System.Int32,System.Action)">
            <summary>
            Fluency method to run an action a certain number of times, eg:
            10.TimesDo(() => Console.WriteLine("Hello World"));
            </summary>
            <param name="howMany">Number of times to run the provided action</param>
            <param name="toRun">Action to run</param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.TimesDo(System.Int32,System.Action{System.Int32})">
            <summary>
            Fluency method to run an action a certain number of times. This
            variant runs on an action given the current index at each run, eg:
            10.TimesDo(i => Console.WriteLine($"This action has run {i} times"));
            </summary>
            <param name="howMany">Number of times to run the provided action</param>
            <param name="toRun">Action to run</param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.Second``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Convenience method to get the second item from a collection
            </summary>
            <param name="src">Source collection</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>The second item, when available. Will throw if there is no item available.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.Third``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Convenience method to get the third item from a collection
            </summary>
            <param name="src">Source collection</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>The third item, when available. Will throw if there is no item available.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.FirstAfter``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Convenience method to get the first item after skipping N items from a collection
            -> equivalent to collection.Skip(N).First();
            -> collection.FirtstAfter(2) returns the 3rd element
            </summary>
            <param name="src">Source collection</param>
            <param name="toSkip">How many items to skip</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>The third item, when available. Will throw if there is no item available.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.FirstOrDefaultAfter``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Convenience method to get the first item after skipping N items from a collection
            -> equivalent to collection.Skip(N).First();
            -> collection.FirtstAfter(2) returns the 3rd element
            -> this variant returns the default value for T if the N is out of bounds
            </summary>
            <param name="src">Source collection</param>
            <param name="toSkip">How many items to skip</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>The third item, when available. Will return the default value for T otherwise.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.FindDuplicates``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Find duplicates within a collectio according to a provided discriminator
            </summary>
            <param name="src">Collection to operate on</param>
            <typeparam name="TItem">Type of items in the collection</typeparam>
            <returns>Collection of duplicate items</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.FindDuplicates``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Find duplicates within a collectio according to a provided discriminator
            </summary>
            <param name="src">Collection to operate on</param>
            <param name="descriminator">Function to determine uniqueness of each item: should
            return whatever identifies a particular item uniquely</param>
            <typeparam name="TItem">Type of items in the collection</typeparam>
            <typeparam name="TKey">Type of key used to discriminate items</typeparam>
            <returns>Collection of DuplicateResult items which contain duplicates, according to the provided discriminator</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.None``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Inverse of All() LINQ method: test should return false for all elements
            </summary>
            <param name="collection"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.None``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Inverse of All() LINQ method: test should return false for all elements
            </summary>
            <param name="collection"></param>
            <param name="test"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.DuplicateResult`2">
            <summary>
            DTO for conveying results from the more complex FindDuplicates
            variant which includes a key discriminator
            </summary>
            <typeparam name="TKey">Type of the key that duplication was determined by</typeparam>
            <typeparam name="TItem">Type of the duplicated item(s)</typeparam>
        </member>
        <member name="P:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.DuplicateResult`2.Key">
            <summary>
            Key of duplication
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.DuplicateResult`2.Items">
            <summary>
            Duplicated items matching this key
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.DuplicateResult`2.#ctor(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Constructs a read-only dto
            </summary>
            <param name="key">Key value</param>
            <param name="items">Duplicated items</param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.ImplicitCast``1(System.Collections.IEnumerable)">
            <summary>
            Performs implicit casting on a collection
            -> just like .Cast&lt;T&gt;, this will explode if the
                cast cannot succeed. C'est la vie
            </summary>
            <param name="collection"></param>
            <typeparam name="TOther"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.StrictZip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Similar to LINQ's Zip extension method, this will zip
            two enumerables together using yield
            - however it will throw an exception if one enumerable
            runs out before the other
            </summary>
            <param name="left">left collection</param>
            <param name="right">right collection</param>
            <typeparam name="TLeft"></typeparam>
            <typeparam name="TRight"></typeparam>
            <returns>A new collection of Tuple&lt;TLeft, TRight&gt;</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.StrictZip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>
            Similar to LINQ's Zip extension method, this will zip
            two enumerables together using yield
            - however it will throw an exception if one enumerable
            runs out before the other
            </summary>
            <param name="left">left collection</param>
            <param name="right">right collection</param>
            <param name="generator">generator function to produce each item of TResult</param>
            <typeparam name="TLeft"></typeparam>
            <typeparam name="TRight"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns>A new collection of TResult, as determined by your generator function</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.Matches``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Performs full-collection matching on two collections of the same type,
            assuming that .Equals() is a valid comparator between two objects of type T
            </summary>
            <param name="left">left collection</param>
            <param name="right">right collection</param>
            <typeparam name="T"></typeparam>
            <returns>
            true if collections are of the same size and each item, in order,
            from the left item, matches the right one
            </returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.Matches``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            Performs matching on collections of the same type
            </summary>
            <param name="left">left collection</param>
            <param name="right">right collection</param>
            <param name="comparer">function used to compare two values</param>
            <typeparam name="T"></typeparam>
            <returns>
            true if collections are of the same size and each item, in order,
            from the left item, matches the right one
            </returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.CrossMatches``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,System.Boolean})">
            <summary>
            Performs cross-type matching on collections
            </summary>
            <param name="left">left collection</param>
            <param name="right">right collection</param>
            <param name="comparer">function to compare items</param>
            <typeparam name="TLeft"></typeparam>
            <typeparam name="TRight"></typeparam>
            <returns>
            true if collections are of the same size and each item, in order,
            from the left item, matches the right one
            </returns>
        </member>
        <member name="T:Imported.PeanutButter.Utils.CannotZipNullException">
            <summary>
            Thrown when an attempt is made to strict-zip null and anything else
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.CannotZipNullException.#ctor">
            <inheritdoc />
        </member>
        <member name="T:Imported.PeanutButter.Utils.UnevenZipException">
            <summary>
            Thrown when an attempt is made to zip two collections of
            uneven size
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.UnevenZipException.#ctor">
            <inheritdoc />
        </member>
        <member name="T:Imported.PeanutButter.Utils.UnevenZipException`2">
            <summary>
            Thrown when an attempt is made to zip two collections of
            uneven size. Also includes references to the two collections.
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.UnevenZipException`2.Left">
            <summary>
            The left collection
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.UnevenZipException`2.Right">
            <summary>
            The right collection
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.UnevenZipException`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc />
        </member>
        <member name="T:Imported.PeanutButter.Utils.PropertyOrFieldTypes">
            <summary>
            Differentiates between PropertyOrField storage for properties or fields
            </summary>
        </member>
        <member name="F:Imported.PeanutButter.Utils.PropertyOrFieldTypes.Property">
            <summary>
            This member is a Property
            </summary>
        </member>
        <member name="F:Imported.PeanutButter.Utils.PropertyOrFieldTypes.Field">
            <summary>
            This member is a Field
            </summary>
        </member>
        <member name="T:Imported.PeanutButter.Utils.PropertyOrField">
            <summary>
            Provides a single storage / representation
            for a Property or a Field
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.Create(System.Reflection.PropertyInfo)">
            <summary>
            Creates a PropertyOrField container for a provided PropertyInfo
            </summary>
            <param name="propertyInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.Create(System.Reflection.FieldInfo)">
            <summary>
            Creates a PropertyOrField container for a provided FieldInfo
            </summary>
            <param name="fieldInfo"></param>
            <returns></returns>
        </member>
        <member name="P:Imported.PeanutButter.Utils.PropertyOrField.Name">
            <summary>
            Name of the property or field
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.PropertyOrField.Type">
            <summary>
            Type of the property or field
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.PropertyOrField.CanWrite">
            <summary>
            Write access to property or field
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.PropertyOrField.CanRead">
            <summary>
            Read access to property or field
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.PropertyOrField.MemberType">
            <summary>
            Is this a Property or a Field?
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.PropertyOrField.DeclaringType">
            <summary>
            The type on which this property or field is declared
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.#ctor(System.Reflection.PropertyInfo)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.op_Implicit(System.Reflection.PropertyInfo)~Imported.PeanutButter.Utils.PropertyOrField">
            <summary>
            Implicitly converts a PropertyInfo object to a PropertyOrField
            </summary>
            <param name="prop"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.op_Implicit(System.Reflection.FieldInfo)~Imported.PeanutButter.Utils.PropertyOrField">
            <summary>
            Implicitly converts a FieldInfo object to a FieldOrField
            </summary>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.#ctor(System.Reflection.FieldInfo)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.GetValue(System.Object)">
            <summary>
            Gets the value of the property or field for the provided host
            </summary>
            <param name="host"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.SetValue(System.Object,System.Object)">
            <summary>
            Sets the value of the property or field on the provided host
            </summary>
            <param name="host"></param>
            <param name="value"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.SetValue``1(``0@,System.Object)">
            <summary>
            Sets the value for the field or property
            as found on the provided host
            </summary>
            <param name="host"></param>
            <param name="value"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrFieldExtensions.IsMatchFor(Imported.PeanutButter.Utils.PropertyOrField,Imported.PeanutButter.Utils.PropertyOrField,System.Boolean)">
            <summary>
            Tests if this PropertyOrField is a match for another
            </summary>
            <param name="master"></param>
            <param name="other"></param>
            <param name="mustMatchMemberType"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrFieldExtensions.PrettyPrint(Imported.PeanutButter.Utils.PropertyOrField)">
            <summary>
            Prints out a pretty representation of this PropertyOrField
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:Imported.PeanutButter.Utils.TypeExtensions">
            <summary>
            Helper extensions for Types
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.Ancestry(System.Type)">
            <summary>
            Enumerates the ancestry of a Type
            </summary>
            <param name="type">Starting Type</param>
            <returns>The Type ancestry, starting from Object</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.AncestryUntil(System.Type,System.Type)">
            <summary>
            Enumerates the ancestry of a Type, from the given type
            - if the given type is not found in the ancestry, the entire ancestry
              will be returned
            - you may provide a generic type without parameters, eg GenericBuilder&lt;,&gt;
              in which case the search is from the first occurence of that generic base type
              within the ancestry tree
            </summary>
            <param name="type">Type to operate on (final type in the result)</param>
            <param name="from">Type to truncate history at (first type in the result, when found)</param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetAllConstants(System.Type)">
            <summary>
            Returns a dictionary of all constant values defined on a Type
            </summary>
            <param name="type">Source type to search for constants</param>
            <returns>Dictionary of constants, keyed by constant name</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetAllConstants``1(System.Type)">
            <summary>
            Returns a dictionary of all constant values of a specified Type found on a Type
            </summary>
            <param name="type">Type to search for constants</param>
            <typeparam name="T">Only return constants of this Type</typeparam>
            <returns>Dictionary of all constant values on a specified type</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetAllConstantValues(System.Type)">
            <summary>
            Returns a collection of all the constant values defined on a Type
            </summary>
            <param name="type">Type to search for constants</param>
            <returns>Collection of the constant values without their defined names</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetAllConstantValues``1(System.Type)">
            <summary>
            Returns a collection of all the constant values defined on a Type, restricted to the required Type T
            </summary>
            <param name="type">Type to search for constants</param>
            <typeparam name="T">Only return constants of this Type</typeparam>
            <returns>Collection of constant values from the source type which match the Type T restriction</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.HasDefaultConstructor(System.Type)">
            <summary>
            Tests if a Type has a default constructor (ie, a constructor with no parameters)
            </summary>
            <param name="type">Type to inspect</param>
            <returns>True when the type has a parameterless constructor; False otherwise. Note that a constructor with parameters which have all default values is not considered valid.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsArrayOrAssignableFromArray(System.Type)">
            <summary>
            Tests if a type is an array or could be assigned from an array
            </summary>
            <param name="t">Type to check</param>
            <returns>True if {t} is an Array type or could have an array type assigned to it; False otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsEnum(System.Type)">
            <summary>
            Provides an extension method mimicking the full framework
            IsEnum for a single point of code usage
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetMethod(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetProperties(System.Type)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetProperty(System.Type,System.String)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetProperty(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetProperties(System.Type,System.Reflection.BindingFlags)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetFields(System.Type,System.Reflection.BindingFlags)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsAssignableFrom(System.Type,System.Type)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetInterfaces(System.Type)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetGenericArguments(System.Type)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetAssembly(System.Type)">
            <summary>
            Provides an extension method mimicking the full framework
            GetAssembly for a single point of code usage
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.BaseType(System.Type)">
            <summary>
            Provides an extension method mimicking the full framework
            BaseType for a single point of code usage
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsGenericType(System.Type)">
            <summary>
            Provides an extension method mimicking the full framework
            IsGenericType for a single point of code usage
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsGenericOf(System.Type,System.Type)">
            <summary>
            Tests if a type is a generic of a given generic type (eg typeof(List&lt;&gt;))
            </summary>
            <param name="t">type to operate on</param>
            <param name="genericTest">type to test against (eg typeof(List&lt;&gt;))</param>
            <returns>True if the input type is a match, false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsAssignableFromArrayOf``1(System.Type)">
            <summary>
            Tests if a type is assignable from an array of T
            </summary>
            <param name="t">Type to test</param>
            <typeparam name="T">Item type of array which calling code would like to assign</typeparam>
            <returns>True if the parameter type is assignable from an array of T</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.ImplementsEnumerableGenericType(System.Type)">
            <summary>
            Tests if a type implements IEnumerable&lt;&gt;
            </summary>
            <param name="t">Type to test</param>
            <returns>True if the source type implements IEnumerable&lt;&gt;; False otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.ImplementsIDictionaryGenericType(System.Type)">
            <summary>
            Returns true if the provided type implements IDictionary&lt;,&gt;
            anywhere in the type heirachy
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsIDictionary(System.Type)">
            <summary>
            Returns true if a type directly implements IDictionary&lt;,&gt;
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.TryGetDictionaryKeyAndValueTypes(System.Type,System.Type@,System.Type@)">
            <summary>
            Tries to get the key and value types for an object, if
            it implements IDictionary&lt;TKey,TValue&gt;. Returns true
            if sucessful (with the out parameters set) or false if
            the provided type does not implement IDictionary&lt;,&gt;
            </summary>
            <param name="type"></param>
            <param name="keyType"></param>
            <param name="valueType"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.TryGetEnumerableInterface(System.Type)">
            <summary>
            Attempts to get the implemented Generic IEnumerable interface for a type, if possible
            </summary>
            <param name="srcType">Type to search for the interface</param>
            <returns>Generic IEnumerable type implemented if found or null otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.TryGetEnumerableItemType(System.Type)">
            <summary>
            Attempts to get the item type (T)
            for a Type which is assumed to implement IEnumerable&lt;T&gt;
            </summary>
            <param name="srcType">Type to search for the IEnumerable &lt;T&gt; interface and underlying type</param>
            <returns>IEnumerable&lt;&gt; item type (T) implemented if found or null otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsGenericOfIEnumerable(System.Type)">
            <summary>
            Tests if a type directly implements the generic IEnumerable interface
            </summary>
            <param name="arg">Type to test</param>
            <returns>True if it does implement the generic IEnumerable; false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetCollectionItemType(System.Type)">
            <summary>
            Attempts to get the item type of a colleciton
            </summary>
            <param name="collectionType">Type to inspect</param>
            <returns>Item type, if it can be found, or null</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetAllImplementedInterfaces(System.Type)">
            <summary>
            Attempts to find all implemented interfaces (and inherited ones) for a Type
            </summary>
            <param name="inspectType">Type to inspect</param>
            <returns>Array of all interfaces which are implemented</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsDisposable(System.Type)">
            <summary>
            Tests if a type implements IDisposable
            </summary>
            <param name="t">Type to test</param>
            <returns>True if it implements IDisposable; false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.PrettyName(System.Type)">
            <summary>
            Provides a "pretty" name for a type, taking into account
            generics and nullable types
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsCollection(System.Type)">
            <summary>
            Rudimentary test for if a type is a collection type, testing for
            IEnumerable&lt;&gt; interface implementation as well as some baked-in
            known generic types
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.CanBeAssignedNull(System.Type)">
            <summary>
            Determines if an object of this type can be assigned null
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsValueType(System.Type)">
            <summary>
            Provides single method to determine IsValueType (shimmed for NETSTANDARD)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsAssignableOrUpcastableTo(System.Type,System.Type)">
            <summary>
            Returns true if the type being operated on can be directly assigned
            or implicitly upcast to the target type
            </summary>
            <param name="src"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.CanImplicitlyUpcastTo(System.Type,System.Type)">
            <summary>
            Returns true if the type being operated on can be
            implicitly upcast to the target type
            </summary>
            <param name="src"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.DefaultValue(System.Type)">
            <summary>
            Returns the default value for the type being operated on
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsInterface(System.Type)">
            <summary>
            Cross-target shim for the IsInterface property,
            found on Type in NetFramework and on Type.GetTypeInf()
            on NETSTANDARD
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsNumericType(System.Type)">
            <summary>
            Determines whether the provided type is a known numeric type
            (ie int / short / byte / double / float / decimal )
            </summary>
            <param name="type">Type to operate on</param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsAncestorOf(System.Type,System.Type)">
            <summary>
            Determines whether the type being operated on is an ancestor of the other type
            </summary>
            <param name="type"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.Implements``1(System.Type)">
            <summary>
            Tests if the type being operated on implements the provided interfaceType
            </summary>
            <param name="type"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.Implements(System.Type,System.Type)">
            <summary>
            Tests if the type being operated on implements the provided interfaceType
            </summary>
            <param name="type"></param>
            <param name="interfaceType"></param>
            <returns></returns>
        </member>
    </members>
</doc>
